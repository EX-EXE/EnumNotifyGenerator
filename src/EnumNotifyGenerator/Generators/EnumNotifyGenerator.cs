using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using System.Diagnostics;
using System.Xml.Linq;
using System.Runtime.InteropServices;
using System.IO;
using EnumNotifyGenerator.Extensions;

namespace EnumNotifyGenerator.Generators;

[Generator(LanguageNames.CSharp)]
public partial class EnumNotifyGenerator : IIncrementalGenerator
{
	private static readonly string EnumNotifyAttribute = "EnumNotifyGenerator.EnumNotifyAttribute";
	private static readonly string EnumValueAttribute = "EnumNotifyGenerator.EnumValueAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Attribute
		context.RegisterPostInitializationOutput(static context =>
			{
				context.AddSource($"{EnumNotifyAttribute}.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
#pragma warning disable CS9113

namespace EnumNotifyGenerator;
using System;
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public class EnumNotifyAttribute(Type type,string propertyName = "") : Attribute
{
}
""");

				context.AddSource($"{EnumValueAttribute}.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
#pragma warning disable CS9113

namespace EnumNotifyGenerator;
using System;
[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
public class EnumValueAttribute(object key, object value) : Attribute
{
}
""");


			});

		// Search
		var source = context.SyntaxProvider.ForAttributeWithMetadataName(
			EnumNotifyAttribute,
			static (node, token) => true,
			static (context, token) => context);
		context.RegisterSourceOutput(source, GenerateSource);
	}
	private static void GenerateSource(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
	{
		context.CancellationToken.ThrowIfCancellationRequested();

		var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
		var typeNode = (TypeDeclarationSyntax)source.TargetNode;

		// partial
		context.CancellationToken.ThrowIfCancellationRequested();
		bool IsPartialKeyword(TypeDeclarationSyntax typeDeclarationSyntax)
		{
			foreach (SyntaxToken modifier in typeDeclarationSyntax.Modifiers)
			{
				if (modifier.IsKind(SyntaxKind.PartialKeyword))
				{
					return true;
				}
			}
			return false;
		}
		if (!IsPartialKeyword(typeNode))
		{
			context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MissingPartialDefinitionError, typeSymbol.Locations.FirstOrDefault(), context));
			return;
		}

		// Field
		context.CancellationToken.ThrowIfCancellationRequested();
		var fieldInfos = new List<EnumValueFieldInfo>();
		foreach (var memberSymbol in typeSymbol.GetMembers())
		{
			context.CancellationToken.ThrowIfCancellationRequested();
			if (memberSymbol is IFieldSymbol fieldSymbol)
			{
				if (fieldSymbol.IsStatic)
				{
					continue;
				}

				// Enum Value Attribute
				var enumValueAttributes = new List<EnumValueAttributeInfo>();
				foreach (var memberAttribute in fieldSymbol.GetAttributes())
				{
					context.CancellationToken.ThrowIfCancellationRequested();
					if (memberAttribute.AttributeClass == null)
					{
						continue;
					}
					if (!memberAttribute.AttributeClass.IsTypeName(EnumValueAttribute))
					{
						continue;
					}
					if (memberAttribute.ConstructorArguments.Length < 2)
					{
						continue;
					}

					var enumTypeSymbol = memberAttribute.ConstructorArguments[0];
					if (enumTypeSymbol.Kind != TypedConstantKind.Enum)
					{
						context.ReportDiagnostic(Diagnostic.Create(
							DiagnosticDescriptors.InvalidEnumTypeFieldError,
							memberAttribute.ApplicationSyntaxReference?.GetSyntax(context.CancellationToken).GetLocation(),
							memberAttribute));
						continue;
					}
					var valueTypeSymbol = memberAttribute.ConstructorArguments[1];
					if (!SymbolEqualityComparer.Default.Equals(fieldSymbol.Type, valueTypeSymbol.Type))
					{
						context.ReportDiagnostic(Diagnostic.Create(
							DiagnosticDescriptors.DifferentTypeWarning,
							memberAttribute.ApplicationSyntaxReference?.GetSyntax(context.CancellationToken).GetLocation(),
							memberAttribute));
					}
					enumValueAttributes.Add(new EnumValueAttributeInfo(memberAttribute, enumTypeSymbol, valueTypeSymbol));
				}
				if (enumValueAttributes.Count <= 0)
				{
					continue;
				}

				// Multiple Enum Type
				bool CheckMultipleEnumTypes(List<EnumValueAttributeInfo> infos)
				{
					if (infos.Count <= 0)
					{
						return false;
					}
					var multiple = false;
					var first = infos[0];
					foreach (var info in infos)
					{
						if (!SymbolEqualityComparer.Default.Equals(first.EnumType.Type, info.EnumType.Type))
						{
							context.ReportDiagnostic(Diagnostic.Create(
								DiagnosticDescriptors.DifferentTypeWarning,
								info.Attribute.ApplicationSyntaxReference?.GetSyntax(context.CancellationToken).GetLocation(),
								info.Attribute));
							multiple |= true;
						}
					}
					return multiple;
				}
				if (CheckMultipleEnumTypes(enumValueAttributes))
				{
					continue;
				}

				// Same Enum Value
				bool CheckSameEnumValues(List<EnumValueAttributeInfo> infos)
				{
					if (infos.Count <= 0)
					{
						return false;
					}

					var same = false;
					var hashSet = new HashSet<EnumValueAttributeInfo>();
					foreach (var src in infos)
					{
						foreach (var comp in infos)
						{
							if (src == comp)
							{
								continue;
							}
							if (hashSet.Contains(src))
							{
								continue;
							}
							if (src.EnumType.Value == comp.EnumType.Value)
							{
								hashSet.Add(src);
								context.ReportDiagnostic(Diagnostic.Create(
									DiagnosticDescriptors.SameEnumValueError,
									src.Attribute.ApplicationSyntaxReference?.GetSyntax(context.CancellationToken).GetLocation(),
									src.Attribute));
								same |= true;
							}
						}
					}
					return same;
				}
				if (CheckSameEnumValues(enumValueAttributes))
				{
					continue;
				}

				// Add
				fieldInfos.Add(
					new EnumValueFieldInfo(
						fieldSymbol,
						enumValueAttributes
						));
			}
		}

		// INotifyPropertyChanged
		context.CancellationToken.ThrowIfCancellationRequested();
		bool IsINotifyPropertyChanged(ITypeSymbol typeSymbol)
		{
			if (typeSymbol.AllInterfaces
				.Any(x => x.IsTypeName("System.ComponentModel.INotifyPropertyChanged")))
			{
				return true;
			}
			if (typeSymbol.BaseType != null)
			{
				if (IsINotifyPropertyChanged(typeSymbol.BaseType))
				{
					return true;
				}
			}
			return false;
		}
		var existINotifyPropertyChanged = IsINotifyPropertyChanged(typeSymbol);

		// Attribute
		context.CancellationToken.ThrowIfCancellationRequested();
		var classNamespace = typeSymbol.ContainingNamespace.IsGlobalNamespace
			? ""
			: $"namespace {typeSymbol.ContainingNamespace};";
		var classFileName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
			.Replace("global::", "")
			.Replace("<", "_")
			.Replace(">", "_");
		var classTypeName = typeSymbol.Name;
		foreach (var attribute in source.Attributes)
		{
			context.CancellationToken.ThrowIfCancellationRequested();
			if (attribute.ConstructorArguments.Length < 2)
			{
				continue;
			}

			var enumTypeSymbol = (INamedTypeSymbol?)null;
			if (attribute.ConstructorArguments[0] is Microsoft.CodeAnalysis.TypedConstant enumTypeConstant &&
				enumTypeConstant.Value is INamedTypeSymbol enumNamedTypeSymbol &&
				enumNamedTypeSymbol.TypeKind == TypeKind.Enum)
			{
				enumTypeSymbol = enumNamedTypeSymbol;
			}
			else
			{
				context.ReportDiagnostic(Diagnostic.Create(
					DiagnosticDescriptors.InvalidEnumTypeClassError,
					attribute.ApplicationSyntaxReference?.GetSyntax(context.CancellationToken).GetLocation(),
					attribute));
				continue;
			}

			var enumPropertyName = "";
			if (attribute.ConstructorArguments[1] is Microsoft.CodeAnalysis.TypedConstant stringTypeConstant &&
				stringTypeConstant.Value is string stringName)
			{
				enumPropertyName = !string.IsNullOrWhiteSpace(stringName)
					? stringName
					: enumTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
			}
			else
			{
				continue;
			}

			AddSource(
				context,
				$"{classFileName}.{enumPropertyName}.g.cs",
				classNamespace,
				classTypeName,
				existINotifyPropertyChanged,
				enumTypeSymbol,
				enumPropertyName,
				fieldInfos.Where(x => x.IsAttributeEnumType(enumTypeSymbol)).ToImmutableArray()
				);
		}
	}


	private static void AddSource(
		SourceProductionContext context,
		string outputFileName,
		string classNamespace,
		string classTypeName,
		bool existINotifyPropertyChanged,
		INamedTypeSymbol enumTypeSymbol,
		string enumPropertyName,
		ImmutableArray<EnumValueFieldInfo> fieldInfos)
	{
		var enumTypeFullName = enumTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		// PropertyChanged
		var sourcePropertyChanged = new StringBuilder();
		if (existINotifyPropertyChanged)
		{
			sourcePropertyChanged.Append(
				$$"""
			if(PropertyChanged != null)
			{
				PropertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs("{{enumPropertyName}}"));
{{string.Join("\n", fieldInfos.Select(x => $"\t\t\t\tPropertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(\"{x.PropertyName}\"));"))}}
			}
""");
		}

		// Property
		var sourceProperty = new StringBuilder();
		foreach (var fieldInfo in fieldInfos)
		{
			sourceProperty.AppendLine(
				$$"""
	/// <summary>
	/// Value change when [{{enumPropertyName}}] is modified.<br/>
	/// Generated by {{nameof(EnumNotifyGenerator)}}.
	/// </summary>
	public {{fieldInfo.FieldSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{fieldInfo.PropertyName}}
	{
		get
		{
			switch(_{{enumPropertyName}})
			{
{{string.Join("\n", fieldInfo.AttributeInfos.Select(x => $"\t\t\t\tcase ({x.EnumType.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}){x.EnumType.Value}:\n\t\t\t\t\treturn {x.ValueType.Value.ToSource()};"))}}
				default:
					break;
			}
			return {{fieldInfo.FieldSymbol.Name}};
		}
	}
""");
		}

		// Source
		var enumCommentBuilder = new StringBuilder();
		enumCommentBuilder.AppendLine($"\t/// <summary>");
		enumCommentBuilder.AppendLine($"\t/// When changing this property, the following properties are being modified.<br/>");
		enumCommentBuilder.AppendLine($"\t/// Generated by {nameof(EnumNotifyGenerator)}.");
		foreach (var fieldInfo in fieldInfos)
		{
			enumCommentBuilder.AppendLine($"\t/// ・{fieldInfo.PropertyName}<br/>");
		}
		enumCommentBuilder.AppendLine($"\t/// </summary>");
		var enumComment = enumCommentBuilder.ToString().TrimEnd();
		var source = $$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;

{{classNamespace}}

partial class {{classTypeName}}
{
{{enumComment}}
	private {{enumTypeFullName}} _{{enumPropertyName}};
{{enumComment}}
	public {{enumTypeFullName}} {{enumPropertyName}}
	{
		get
		{
			return _{{enumPropertyName}};
		}
		set
		{
			if(_{{enumPropertyName}} == value)
			{
				return;
			}
			_{{enumPropertyName}} = value;
{{sourcePropertyChanged}}
		}
	}

{{sourceProperty}}
}

""";
		context.AddSource(outputFileName, source);
	}

}

public class EnumValueAttributeInfo(
	AttributeData attribute,
	TypedConstant enumType,
	TypedConstant valueType)
{
	public AttributeData Attribute { get; } = attribute;
	public TypedConstant EnumType { get; } = enumType;
	public TypedConstant ValueType { get; } = valueType;
}

public class EnumValueFieldInfo(
	IFieldSymbol fieldSymbol,
	IEnumerable<EnumValueAttributeInfo> infos)
{
	public string PropertyName { get; } = ConvertPropertyName(fieldSymbol);
	public IFieldSymbol FieldSymbol { get; } = fieldSymbol;
	public ImmutableArray<EnumValueAttributeInfo> AttributeInfos { get; } = infos.ToImmutableArray();


	public bool IsAttributeEnumType(ISymbol enumTypeSymbol)
	{
		if (AttributeInfos.Length <= 0)
		{
			return false;
		}
		return SymbolEqualityComparer.Default.Equals(enumTypeSymbol, AttributeInfos[0].EnumType.Type);
	}
	private static string ConvertPropertyName(IFieldSymbol fieldSymbol)
	{
		var name = fieldSymbol.Name;
		name = name.TrimStart('_');
		if (0 < name.Length)
		{
			name = $"{Char.ToUpper(name[0], System.Globalization.CultureInfo.InvariantCulture)}{name.AsSpan(1).ToString()}";
		}
		return name;
	}
}
